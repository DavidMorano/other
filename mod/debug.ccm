/* debug MODULE */
/* charset=ISO8859-1 */
/* lang=C++20 (conformance reviewed) */

/* UNIX® kernel support subroutines */
/* version %I% last-modified %G% */


/* Copyright © 1998 David A­D­ Morano.  All rights reserved. */

module ;

#include	<envstandards.h>	/* ordered first to configure */
#include	<sys/param.h>		/* |MAXPATHLEN| */
#include	<unistd.h>		/* |write(2)| */
#include	<cerrno>
#include	<climits>		/* |INT_MAX| */
#include	<cstddef>		/* |nullptr_t| */
#include	<cstdlib>
#include	<cstdarg>		/* |va_list(3c)| */
#include	<new>			/* |nullptr_t| */
#include	<clanguage.h>
#include	<utypedefs.h>
#include	<utypealiases.h>
#include	<usysdefs.h>
#include	<usysrets.h>
#include	<usysutility.hh>	/* |snvprintf(3u)| */
#include	<getfdfile.h>		/* |FD_STDERR| */
#include	<localmisc.h>

export module debug ;

using std::nullptr_t ;			/* type */
using libu::snprintf ;			/* subroutine */
using libu::snvprintf ;			/* subroutine */
using std::nothrow ;			/* constant */

constexpr int		flen = MAXPATHLEN ;

static int		dfd = -1 ;

export {
    int debfd(int) noex ;
    int debprintf(cchar *fmt,...) noex ;
} /* end export */

int debfd(int fd) noex {
    	dfd = fd ;
	return SR_OK ;
} /* end subroutine (debfd) */

int debprintf(cchar *fmt,...) noex {
    	va_list		ap ;
	cnullptr	np{} ;
    	int		rs = SR_FAULT ;
	if (fmt) {
	    va_begin(ap,fmt) ;
    	    rs = SR_NOMEM ;
	    if (char *fbuf ; (fbuf = new(nothrow) char[flen + 1]) != np) {
	        if ((rs = snvprintf(fbuf,flen,fmt,ap)) >= 0) {
		    if ((rs = write(dfd,fbuf,rs)) < 0) {
			rs = (- errno) ;
		    }
	        } /* end if (snvprintf) */
		delete [] fbuf ;
	    } /* end if (m-a-f) */
	    va_end(ap) ;
	} /* end if (non-null) */
	return rs ;
} /* end subroutine (debprintf) */


