/* strfilter MODULE (primary-module-interface) */
/* charset=ISO8859-1 */
/* lang=C++20 (conformance reviewed) */

/* manage a variable length bit-array */
/* version %I% last-modified %G% */


/* revision history:

	= 1998-09-10, David A­D­ Morano
	This subroutine was written for Rightcore Network Services.

	= 2020-08-13, David A­D­ Morano
	This code has been modularized (w/ C++20 modules).
	There was really no good reason for this.  In many cases,
	w/ my limited experience w/ modules so far, sometimes
	modules are more of a hassle than they are worth.

*/

/* Copyright © 1998,2020 David A­D­ Morano.  All rights reserved. */

/*******************************************************************************

	Module:
	strfilter

	Description:
	This object implements a (fast) filter for strings.

	Synopsis:

	Arguments:

	Returns:
	>=0		number of matches before target count reached
	<0		error (system-return)

*******************************************************************************/

module ;

#include	<envstandards.h>	/* MUST be first to configure */
#include	<climits>		/* |UCHAR_MAX| + |CHAR_BIT| */
#include	<cstddef>		/* |nullptr_t| */
#include	<cstdlib>
#include	<new>			/* |nothrow(3c++)| */
#include	<bitset>
#include	<vector>
#include	<string>
#include	<algorithm>		/* |min(3c++)| + |max(3c++)| */
#include	<clanguage.h>
#include	<utypedefs.h>
#include	<utypealiases.h>
#include	<usysdefs.h>
#include	<usysrets.h>
#include	<umemalloc.hh>
#include	<mkchar.h>
#include	<localmisc.h>

export module strfilter ;

import libutil ;
import ureserve ;			/* |vecstr(3u)| */

/* local defines */

#define	STRFILTER_MAGIC		0x98865854


/* imported namespaces */

using std::nullptr_t ;			/* type */
using std::bitset ;			/* type */
using std::vector ;			/* type */
using std::string ;			/* type */
using std::min ;			/* subroutine */
using std::max ;			/* subroutine */
using libu::umemallocstrw ;		/* subroutine */
using libu::umemalloc ;			/* subroutine */
using libu::umemvalloc ;		/* subroutine */
using libu::umemcalloc ;		/* subroutine */
using libu::umemrealloc ;		/* subroutine */
using libu::umemfree ;			/* subroutine */
using libu::umemrsfree ;		/* subroutine */
using std::nothrow ;			/* constant */


/* local typedefs */


/* external subroutines */


/* external variables */


/* local structures */

    enum strfiltermems {
	strfiltermem_start,
	strfiltermem_finish,
	strfiltermem_extent,
	strfiltermem_count,
	strfiltermem_ready,
	strfiltermem_overlast
    } ; /* end enum (vecvoolmems) */

constexpr cint		tlen = (UCHAR_MAX + 1) ;

export {
    struct strfilter_fl {
	uint		open:1 ;
	uint		ready:1 ;
    } ;
    struct strfilter ;
    struct strfilter_co {
	strfilter	*op = nullptr ;
	int		w = -1 ;
	void operator () (strfilter *p,int m) noex {
	    op = p ;
	    w = m ;
	} ;
	operator int () noex ;
	int operator [] (int) noex ;
    } ; /* end struct (strfilter_co) */
    struct strfilter : vecstr {
	friend 		strfilter_co ;
	strfilter_co	start ;
	strfilter_co	finish ;
	strfilter_co	extent ;
	strfilter_co	count ;
	strfilter_co	ready ;
	strfilter_fl	fl{} ;
	bitset<tlen>	filtchr ;
	ulong		*filtarr{} ;
	uint		magic{} ;
	int		idx ;		/* highest index */
	int		e ;		/* extent */
	strfilter() noex {
	    start	(this,strfiltermem_start) ;
	    finish	(this,strfiltermem_finish) ;
	    extent	(this,strfiltermem_extent) ;
	    count	(this,strfiltermem_count) ;
	    ready	(this,strfiltermem_ready) ;
	} ;
	int add(cchar *,int = -1) noex ;
	int have(cchar *,int = -1) noex ;
	operator int () const noex {
	    cint rs = vecstr::icount() ;
	    return rs ;
	} ;
	void dtor() noex ;
	destruct strfilter() {
	    if (fl.open || magic) dtor() ;
	} ;
    private:
	int istart() noex ;
	int ifinish() noex ;
	int icount() noex ;
	int ihave(cchar *,int) noex ;
	int inschrs(cchar *,int) noex ;
    } ; /* end struct (strfilter) */
} /* end export */


/* forwards references */

static ulong mksw(cchar *sp,int sl) noex {
    	cint	n = min(sl,szof(ulong)) ;
    	ulong	res = 0 ; /* return-value */
	for (int i = 0 ; i < n ; i += 1) {
	    ulong v = mkchar(*sp++) ;
	    v <<= (CHAR_BIT * i) ;
	    res |= v ;
	} /* end for */
	return res ;
} /* end method (mksw) */


/* local variables */


/* exported variables */


/* exported subroutines */

int strfilter::istart() noex {
    	int		rs ;
	if ((rs = vecstr::start) >= 0) {
	    fl.open = true ;
	    magic = STRFILTER_MAGIC ;
	}
	return rs ;
} /* end method (strfilter::istartadd) */

int strfilter::ifinish() noex {
    	int		rs = SR_NOTOPEN ;
	int		rs1 ;
	if (magic == STRFILTER_MAGIC) {
	    rs = SR_OK ;
	    if (filtarr) {
		rs1 = umemfree(filtarr) ;
		if (rs >= 0) rs = rs1 ;
		filtarr = nullptr ;
	    }
	    {
	        rs1 = vecstr::finish() ;
		if (rs >= 0) rs = rs1 ;
	    }
	    fl.open = false ;
	    magic = 0 ;
	} /* end if (magic) */
	return rs ;
} /* end method (strfilter::ifinsh) */

int strfilter::add(cchar *sp,int sl) noex {
    	int		rs = SR_FAULT ;
	if (sp) {
	    if (sl < 0) sl = xstrlen(sp) ;
	    rs = SR_INVALID ;
	    if (sl > 0) {
	        if ((rs = ihave(sp,sl)) == 0) {
	            if ((rs = inschrs(sp,sl)) >= 0) {
			rs = vecstr::add(sp,sl) ;
	            }
	        }
	    } /* end if (valid) */
	} /* end if (non-null) */
	return rs ;
} /* end method (strfilter::add) */

int strfilter::have(cchar *sp,int sl) noex {
    	int		rs = SR_FAULT ;
	if (sp) {
	    if (sl < 0) sl = xstrlen(sp) ;
	    rs = SR_INVALID ;
	    if (sl > 0) {
	        rs = ihave(sp,sl) ;
	    }
	}
	return rs ;
} /* end method (strfilter::have) */

int strfilter::ihave(cchar *sp,int sl) noex {
	constexpr cint	sz = szof(ulong) ;
    	cint		ch = mkchar(*sp) ;
    	int		rs = SR_OK ;
	int		f = false ;
	if (bool(filtchr[ch])) {
	    ulong	sw = mksw(sp,sl) ;
	    cint	rl = (sl - sz) ;
	    for (int i = 0 ; i < idx ; i += 1) {
		if ((f = (filtarr[i] == sw))) break ;
	    }
	    if (f && (rl > 0)) {
		rs = vecstr::search(sp,sl) ;
		f = rs ;
	    }
	}
	return (rs >= 0) ? f : rs ;
} /* end method (strfilter::ihave) */

int strfilter::inschrs(cchar *sp,int sl) noex {
    	cint		ch = mkchar(*sp) ;
    	int		rs = SR_OK ;
	filtchr[ch] = true ;
	(void) sl ;
	return rs ;
} /* end method (strfilter::inschrs) */



